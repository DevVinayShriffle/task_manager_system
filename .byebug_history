c
session[:token]
session
token
c
n
nn
n
task.update(status: "pending")
task && task.status == 'progress'
ask && task.status == 'progress'
token
session[:token]
session
c
n
@task
n
@user
n
@user
params
c
task && task.status == 'pending' && task.updated_at < 1.minute
task && task.status == 'pending'
task
n
task.user
task
task_id
c
flash[:error].match("Email has already been taken")
flash[:error]
c
params
Task.search({ query: { bool: { must: [ { multi_match: { query: params[:query]}}]}}})
Task.search(params[:query])
params[:query]
params
search_results
n
c
if params[:query].present?
n
c
n
search_results
n
c
params[:query]
if params[:query].present?
params
c
params
c
n
UserMailer.welcome_email(user)
user
c
c!
redirect_to users_task_path(task)
format.html { redirect_to users_task_path(task), notice: "Task created." }
n
task
params[:format]
params
c!
task
c
task
c
params[:format]
task[:format]
format
c
n
task
c
redirect_to users_task_path(task)
n
task
c
n
redirect_to(users_task_path(task))
users_task_path(task)
c
mn
task
@current_user
session[:token]
task
c!
task
c
task
c!
users_tasks_path(task)
task
c!
n
JSON.parse(response.body)
c!
c
n
c
params[:format]
params
params.format
params
task
n
@current_user.tasks.create!(task_params)
@current_user
task_params
c
task
n
task
params
c!
c
n
c
task
n
c
nc
n
c
params
task
JSON.parse(response.body)
session[:token]
token
c
c!
JSON.parse(response.body)
c
c!
json
response.headers
JSON.parse(response.body)
c
c!
response.body
    response.headers["Authorization"] = "Bearer #{JsonWebToken.encode(user_id: user.id)}"
@token
response.headers["Authorization"]
c
c!
JSON.parse(response.body)
request.headersJSON.parse(response.body)
request.headers
c
c!
request.headers.token
request.headers
c
c!
 JSON.parse(response.body)
c
c!
JSON.parse(response.body)
c
n
mn
n
c!
c
n
"Bearer #{JsonWebToken.encode(user_id: user.id)}"
c
params
c
params
c
JWT.decode(token, SECRET_KEY)
token
decoded
n
c
token
c
request.format.json?
request.format
c
request.format.json?
request.format
c
request.format.json?
c
request.format.json?
request.format
c
request.format.json?
request.format.hash?
request.format.hash
request.format.hash]
request.format
request.json
request.json?
request.type
request.typer
request
c
request.format.json?
request.format
request
c
request.format
request
c
request.format.json?c
request.format.json
request.format
request
c
respond_to
n
c
verify_authenticity_token
verify_authenticity_token,
request
c
JWT.decode(token, SECRET_KEY)
SECRET_KEY
token
c
ActiveRecord::Base.connection_db_config.database
User.all
user
c
delete :logout
expect(session[:token]).to be_nil
c
expect(session[:token]).to be_nil
n
session[:token]
sesson[:token]
token
c
flash[:error]
n
c
n
c
errors[0].split(': ')[1]
errors[0].split(': ')
errors[0].split(' ')
errors[0]
errors[0].include?('email')
errors
error
n
N
c
